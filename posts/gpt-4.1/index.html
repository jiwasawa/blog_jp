<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Junichiro Iwasawa">
<meta name="dcterms.date" content="2025-05-21">
<meta name="description" content="GPT-4.1開発者のインタビューから、急速に進化するAI評価の課題と開発者が最新モデルを最大限に活用するためのプロンプト術やfine-tuning戦略を考える。">

<title>GPT-4.1の深層: 開発リーダーが語る「開発者が喜ぶAI」への道と、評価の賞味期限</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-a98ec624fb63d9b712fc3a6f62e2b305.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-8BXHXPDSCJ"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-8BXHXPDSCJ', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="GPT-4.1の深層: 開発リーダーが語る「開発者が喜ぶAI」への道と、評価の賞味期限 – jiwasawaのブログ">
<meta property="og:description" content="GPT-4.1開発者のインタビューから、急速に進化するAI評価の課題と開発者が最新モデルを最大限に活用するためのプロンプト術やfine-tuning戦略を考える。">
<meta property="og:image" content="https://picsum.photos/id/95/200">
<meta property="og:site_name" content="jiwasawaのブログ">
<meta name="twitter:title" content="GPT-4.1の深層: 開発リーダーが語る「開発者が喜ぶAI」への道と、評価の賞味期限 – jiwasawaのブログ">
<meta name="twitter:description" content="GPT-4.1開発者のインタビューから、急速に進化するAI評価の課題と開発者が最新モデルを最大限に活用するためのプロンプト術やfine-tuning戦略を考える。">
<meta name="twitter:image" content="https://picsum.photos/id/95/200">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">jiwasawaのブログ</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Junichiro Iwasawa</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/jiwasawa"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/junichiro-iwasawa-875b37130/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jiwasawa"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">GPT-4.1の深層: 開発リーダーが語る「開発者が喜ぶAI」への道と、評価の賞味期限</h1>
                  <div>
        <div class="description">
          GPT-4.1開発者のインタビューから、急速に進化するAI評価の課題と開発者が最新モデルを最大限に活用するためのプロンプト術やfine-tuning戦略を考える。
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">LLM</div>
                <div class="quarto-category">AI</div>
                <div class="quarto-category">Podcast</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Junichiro Iwasawa </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 21, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>OpenAIでGPT-4.1開発の鍵を握る一人、事後学習研究リーダーのMichelle Pokrass氏が、<a href="https://www.youtube.com/watch?v=NNGbaiN1L7Y&amp;t=3s">Unsupervised Learning podcast のインタビュー</a>でその開発秘話やAIの未来について赤裸々に語った。GPT-4.1がいかにして指示追従性とlong context処理能力を高め、開発者にとって「使って楽しい」モデルへと進化したのか。そして、なぜAIの評価ベンチマーク（eval）は3ヶ月で陳腐化するのか。成功するAIスタートアップは何が違うのか。最前線のチームはfine-tuningをどう活用し、現在の限界を突破しようとしているのか。</p>
<p>本稿では、Pokrass氏のインタビュー内容とOpenAIが公開した<a href="https://cookbook.openai.com/examples/gpt4-1_prompting_guide">GPT-4.1のプロンプトガイド</a>を基に、これらの疑問を深掘りしていく。特に、ベンチマークとの向き合い方、GPT-4.1を使いこなすためのプロンプト術、そして Reinforcement Fine-tuning（RFT）、Supervised Fine-tuning（SFT）、Preference Fine-tuning の戦略的な使い分けについて考察していく。</p>
<section id="gpt-4.1は開発者の喜びを追求指示追従性とlong-contextへの賭け" class="level2">
<h2 class="anchored" data-anchor-id="gpt-4.1は開発者の喜びを追求指示追従性とlong-contextへの賭け">GPT-4.1は「開発者の喜び」を追求：指示追従性とlong contextへの賭け</h2>
<p>Pokrass氏によれば、GPT-4.1開発の真の目標は「開発者にとって使って楽しい（a joy to use for developers）」モデルを実現することだったという。従来のモデル開発では、しばしばベンチマークのスコアを追い求めるあまり、実際の利用シーンで「指示に従わない」「フォーマットがおかしい」「コンテキストが短すぎて役に立たない」といった基本的な問題で躓くことがあった。OpenAIも例外ではないと認めている。</p>
<p>そこでGPT-4.1では、開発者からの長年のフィードバックに真摯に耳を傾け、それを具体的な評価（Eval）に落とし込むことから始めた。モデルトレーニングに着手するかなり前から、ユーザーインタビューを重ね、問題点を洗い出し、社内で実際に使われているAPIの利用状況に基づいた独自の「指示追従性評価（instruction following eval）」を構築。これが開発の北極星となった。</p>
<p>特に、<strong>指示追従性</strong>と<strong>long context</strong>への対応は最優先事項だった。Pokrass氏が最近ユーザーから得た洞察として、「世の中の知識をすべて無視し、提供されたコンテキスト内の情報だけを使う」能力の向上が挙げられる。これは従来のベンチマークでは測れないが、特定のユースケースでは極めて重要な能力だ。</p>
</section>
<section id="ai評価evalの賞味期限は3ヶ月常に新たな評価を求める理由" class="level2">
<h2 class="anchored" data-anchor-id="ai評価evalの賞味期限は3ヶ月常に新たな評価を求める理由">AI評価（Eval）の賞味期限は3ヶ月：常に新たな評価を求める理由</h2>
<p>Pokrass氏は「Evalの賞味期限は3ヶ月程度」と語る。AIの進歩はあまりにも速く、既存の評価はすぐに飽和してしまう。だからこそ、OpenAIは常に新しい評価基準やテスト例を求めている。特に「long contextでの実世界Eval」や、より多様な「指示追従性」のケースを渇望しているという。</p>
<p>この話は、AIを活用するスタートアップにとっても示唆に富む。<strong>成功しているAIスタートアップは、自分たちのユースケースを深く理解し、質の高い独自のEvalを持っている</strong>とPokrass氏は指摘する。新しいモデルがリリースされた際、これらの企業は1時間程度で自社のEvalを回し、迅速にその価値を判断できる。そして、モデルの特性に合わせてプロンプトや周辺の仕組み（スキャフォールディング）を調整する柔軟性も併せ持つ。</p>
<p>さらに、<strong>「現在のモデルでは手が届きそうで届かない」あるいは「10回に1回しか成功しないが、9回成功させたい」ようなユースケースを常にストックしておく</strong>ことが、競争優位性を築く鍵だという。新しいモデルが登場した瞬間に、それらの課題が解決され、市場をリードできるからだ。Pokrass氏の経験則では、ベースモデルで10%程度の成功率のものが、fine-tuningで50%まで向上するようなタスクは、数ヶ月後の次世代モデルで容易に達成される可能性が高い「手が届きそうな」領域だと言える。</p>
</section>
<section id="gpt-4.1を使いこなすプロンプト術とfine-tuning戦略" class="level2">
<h2 class="anchored" data-anchor-id="gpt-4.1を使いこなすプロンプト術とfine-tuning戦略">GPT-4.1を使いこなす：プロンプト術とfine-tuning戦略</h2>
<p>GPT-4.1は指示に対してより忠実かつ文字通りに従うように訓練されている。これは、以前のモデルがユーザーの意図をより広範に推測していたのとは対照的だ。つまり、<strong>GPT-4.1は明確で具体的な指示によって、その挙動を精密にコントロールできる</strong>ということでもある。</p>
<section id="プロンプトエンジニアリングのヒント" class="level3">
<h3 class="anchored" data-anchor-id="プロンプトエンジニアリングのヒント">プロンプトエンジニアリングのヒント</h3>
<p><a href="https://platform.openai.com/docs/guides/text?api-mode=responses#prompting-gpt-4-1-models">OpenAIのプロンプトガイド</a>とPokrass氏のインタビューから、いくつかの重要なヒントが見えてくる。</p>
<ol type="1">
<li><strong>構造化されたプロンプト</strong>:
<ul>
<li>XMLタグやMarkdown形式でプロンプトを明確に構造化すると、モデルの理解度が向上する。特にlong contextでは、指示をコンテキストの最初と最後に配置することが推奨される。</li>
<li><strong>推奨される区切り文字</strong>: Markdown（H1-H4タグ、バッククォート、リスト）、XML（ネスト構造やメタデータ付与に便利）。長文ドキュメントの場合、JSONは冗長になるため、XMLや<code>ID: 1 | TITLE: The Fox | CONTENT: ...</code>のような形式が良い。</li>
</ul></li>
<li><strong>エージェント的ワークフローにおけるシステムプロンプト</strong>:
<ul>
<li><strong>永続性 (Persistence)</strong>: 「ユーザーのクエリが完全に解決されるまで処理を続け、確信するまで終了しないでください」といった指示で、モデルが途中で諦めるのを防ぐ。Podcastの中でもこの「keep going」プロンプトが「面白い発見」として語られている。次世代モデルではこのようなプロンプトがなくともうまくいくよう修正を目指しているものの、現状では顕著な性能向上が見られるという。</li>
</ul>
<pre><code>You are an agent - please keep going until the user’s query is completely resolved, before ending your turn and yielding back to the user. Only terminate your turn when you are sure that the problem is solved.</code></pre>
<ul>
<li><strong>ツール呼び出し (Tool-calling)</strong>: 「ファイル内容やコードベース構造が不確かな場合は、ツールを使って情報を収集してください。推測や捏造はしないでください」と促し、ツールの積極的な利用を奨励する。</li>
</ul>
<pre><code>If you are not sure about file content or codebase structure pertaining to the user’s request, use your tools to read files and gather the relevant information: do NOT guess or make up an answer.</code></pre>
<ul>
<li><strong>計画 (Planning) [オプション]</strong>: 「各関数呼び出しの前に広範に計画し、前回の関数呼び出しの結果を広範に考察してください」と指示し、思考プロセスを明示させる（いわゆるChain-of-Thought）。これにより、SWE-bench Verifiedのスコアが4%向上したという。</li>
</ul>
<pre><code>You MUST plan extensively before each function call, and reflect extensively on the outcomes of the previous function calls. DO NOT do this entire process by making function calls only, as this can impair your ability to solve the problem and think insightfully.</code></pre></li>
<li><strong>ツールの利用</strong>: ツールはプロンプト内に手動で記述するのではなく、OpenAI APIの<code>tools</code>フィールドを通じて渡すことが強く推奨される。これによりエラーを最小限に抑え、モデルが期待通りに動作しやすくなる。ツールの名前と説明は明確にし、複雑な場合はシステムプロンプトの<code># Examples</code>セクションで使用例を示すと良い。</li>
</ol>
</section>
<section id="fine-tuning戦略sftrftpreference-tuningの使い分け" class="level3">
<h3 class="anchored" data-anchor-id="fine-tuning戦略sftrftpreference-tuningの使い分け">Fine-tuning戦略：SFT、RFT、Preference tuningの使い分け</h3>
<p>Pokrass氏はOpenAIの提供するfine-tuningサービスについて、以下のように整理している。</p>
<ol type="1">
<li><strong>Supervised Fine-Tuning - SFT</strong>:
<ul>
<li><strong>用途</strong>: 主に速度とレイテンシの改善。例えば、GPT-4.1の能力をより軽量なnanoモデルで、低コスト・低遅延で実現したい場合。nanoモデルが特定の分類タスクで10%間違えるのを修正するなど、既存能力の移植や補強に適している。</li>
<li><strong>データ効率</strong>: 比較的少量のデータで効果が見られる。</li>
</ul></li>
<li><strong>Reinforcement Fine-Tuning - RFT</strong>:
<ul>
<li><strong>用途</strong>: フロンティア（最先端）の能力を開拓する。市場のどのモデルも対応できないような、特定のニッチな領域で限界を押し上げる。エージェントに特定のワークフローの選択方法を教えたり、意思決定プロセスを改善したりするのに有効。OpenAI内部で使っている強化学習のワークフローと同じものが使われているとpodcast内で語られている。</li>
<li><strong>データ効率</strong>: 非常にデータ効率が高く、数百サンプル程度でも効果を発揮する。</li>
<li><strong>特に有効なドメイン</strong>: チップ設計、生物学（創薬など）、結果が検証可能な分野。Pokrass氏は、OpenAI内部でモデル改善に使っているRLプロセスとRFTは基本的に同じであり、SFTよりも頑健だと強調する。</li>
</ul></li>
<li><strong>Preference Fine-tuning (Direct Preference Optimization)</strong>:
<ul>
<li><strong>用途</strong>: 主に文体やトーンといったスタイルに関する調整。モデルの応答が特定の好みに合うようにしたい場合に利用する。</li>
</ul></li>
</ol>
</section>
</section>
<section id="aiエージェントとモデルの未来汎用性と特化性の狭間で" class="level2">
<h2 class="anchored" data-anchor-id="aiエージェントとモデルの未来汎用性と特化性の狭間で">AIエージェントとモデルの未来：汎用性と特化性の狭間で</h2>
<p>AIエージェントの現状について、Pokrass氏は「明確にスコープが定められたドメインでは驚くほどうまく機能する」と述べる。適切なツールが提供され、ユーザーの要求が明確な場合だ。しかし、課題は「曖昧で厄介な実世界」とのギャップを埋めること。ユーザーはエージェントの能力を知らず、エージェントも自身の能力を把握しきれていない。また、曖昧な指示に対して、ユーザーに追加情報を求めるべきか、仮定に基づいて進むべきか、そのバランスを開発者が調整しやすくする必要がある。</p>
<p>モデルファミリーの進化については、Pokrass氏の哲学は「AGIのG（General）に注力し、汎用的な単一モデルを目指すべき」というものだ。長期的には製品ラインナップをシンプルにし、ChatGPTのモデルセレクターも簡素化したい考えだ。しかし、GPT-4.1に関しては、API開発者という特定のグループのニーズが切実であり、ChatGPT本体から切り離すことで、より迅速な開発・フィードバック・デプロイが可能になった。コーディング関連のデータを大幅に増やし、ChatGPT特有のデータセットを一部削除するといった、特化型ならではの最適化も行えた。</p>
<p>将来的には、GPT-5のような形でモデルファミリーが統合され、ユーザーがモデル選択に悩む必要がなくなることが期待される。しかし、特定のニーズに応じた「特化型」アプローチも、時には有効な選択肢として残り続けるだろう。</p>
</section>
<section id="まとめ変化の波を乗りこなす開発者たちへ" class="level2">
<h2 class="anchored" data-anchor-id="まとめ変化の波を乗りこなす開発者たちへ">まとめ：変化の波を乗りこなす開発者たちへ</h2>
<p>Michelle Pokrass氏の話は、AI開発の最前線が、単なる技術的進歩だけでなく、ユーザーとの対話、評価方法の革新、そして戦略的なfine-tuningによって切り拓かれていることを示している。</p>
<p>開発者にとって重要なのは、</p>
<ul>
<li>自社のユースケースを深く理解し、独自の評価軸を持つこと。</li>
<li>プロンプトエンジニアリングの技術を磨き、モデルの特性を最大限に引き出すこと。</li>
<li>Fine-tuningの選択肢（SFT, RFT, Preference FT）を理解し、目的に応じて戦略的に活用すること。</li>
<li>「現在のモデルでは少し手が届かない」課題に常に挑戦し続けること。</li>
</ul>
<p>AIの進化は止まらない。その変化の波を乗りこなし、新たな価値を創造していくためには、Pokrass氏が語るような「地に足のついた」アプローチと、未来を見据えた実験を続ける姿勢が不可欠だろう。</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/jiwasawa\.github\.io\/blog_jp");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>